
https://www.zhihu.com/question/37019479



gzip 只是一个流压缩程序，输入一个流，输出压缩后的数据流。给它一个文件，文件本身自然就是一个流，读入、压缩、输出，
还是保存成一个文件，没有问题。然而，如果是一个文件夹、多个文件，该怎么办呢？按什么顺序？怎么存储文件以外的信息？
（例如路径、权限。）操作系统没有提供一种可以把若干个文件组织成一个流的 API ，gzip 就无能为力。tar 则相反，
它就是一个打包程序。天生就是为了处理打包多个文件的问题，它有专门的 manifest 来存储一些 metadata ，包括包里有什么
文件、（相对）路径是什么、在包里的偏移量是什么……不过，它（最早）没有压缩功能。想要打包多个文件，很简单，先 tar 
再 gzip ，一个管道就搞定了。后缀名自然而然就是 .tar.gz 了。以上说的都是历史上最早的 UNIX 工具。这些工具的设计很好
地体现了 UNIX 一个工具只做一件事情、使用管道组合多个工具的思想。当然，到了后来，大家也都觉得这样很麻烦，而且这个功能
太过常用了。所以 GNU 项目在复刻 UNIX tar 的时候，选择了把各种常用的压缩解压都集成进 tar （详见下段），然后提供了
一套（丧心病狂的）命令行参数，现在一条命令就可以完成打包加压缩了。解压也是一样，使用 GNU 的 tar 的话，一条命令就可
以自动完成压缩加解包，不需要先 gunzip 。关于 tar 调用其他压缩解压程序，之前误以为是链接了 zlib 、 bzip2 等等这些库，
然而只需要简单的 ldd `which tar` 或者看各个发行版里 tar 软件包的依赖信息，就可以知道事情并非如此。 tar 的依赖仍然是非常少的。
而压缩解压其实仍然是通过管道调用了这些独立的外部程序来实现的。这可以通过看 tar 的源代码、看 tar 二进制里的 strings 
（有很多常见压缩解压程序的命令名）、或者看压缩解压时的进程来发现。感谢 @王铭烨 Arthur2e5 指出。最后，其实现代的 GNU tar 是有一套
根据扩展名自动识别压缩算法的机制的，免去了手动通过参数指定压缩算法的麻烦。压缩时使用 tar caf ，解压时使用 tar xaf 即可。其中 a 表示
自动检测，这个 a 也可以省略，然而个人还是习惯输入——因为如果万一某个地方的 tar 版本不支持自动检测，你至少还能得到一个警告，否则 tar cf 的
话最后可能建立了一个 foo.tar.gz 的没有压缩的 tar 包